/*Программа запрашивает вершины s и q и выводит кратчайший путь. Например, после ввода s = 3, q = 6, программа выводит 

Нет пути из вершины 3 в вершину 6. 

После ввода s = 0, q = 2 программа выводит 

Кратчайший путь из вершины 0 в вершину 2: 2 5 1 0 - выводит находимые кратчайшие расстояния по очередности их нахождения. Длина пути = 3.*/

#include "stdafx.h"
#include <iostream>
#include <conio.h>

#define VERTEXES 6	//Число вершин в графе
using namespace std;

int a;								// Глобальная переменная, обозначающая текущую вершину.
int main(int argc, char* argv[])
{
	setlocale (LC_CTYPE,"rus");
   int infinity=1000;                     // Условная бесконечность
   int p= VERTEXES;				// Количество вершин в графе
   int a[VERTEXES][VERTEXES]={ 0,1,0,0,1,3,  // Матрица смежности графа(сколько от какой точки идти до другой), можно было бы и динамически задавать и инициализацию оставить за пользователем.
                               1,0,5,0,0,1,
                               0,5,0,5,20,1,
     	                       0,0,5,0,3,2,
                               1,0,20,3,0,10,
                               3,1,1,2,10,0 };

   
   int s;              		// Номер исходной вершины, от которой ищем расстояние
   int g;              		// Номер конечной вершины, до которой ищем расстояние
   cout<<"Введите s: ";  	
   cin>>s;
   cout<<"Введите g: ";
   cin>>g;
   int x[VERTEXES]; //Массив, содержащий единицы и нули для каждой вершины, 1, если кратчайший путь уже найден, 0 - если еще не найден
   int t[VERTEXES];  //t[i] - длина кратчайшего пути от вершины s в i
   int h[VERTEXES];  //h[i] - вершина, предшествующая i-й вершине

					 // Далее инициализация введенных выше массивов
   int b;		    // Счетчик вершин
   for (b=0;b<p;b++)
   {
      t[b]=infinity; //Сначала все кратчайшие пути из s в i равны бесконечности
      x[b]=0;        // Ни для какой из вершин нет кратчайшего пути
   }
   h[s]=0;			 // s - начало пути, поэтому этой вершине ничего не предшествует
   t[s]=0;			 // Кратчайший путь из s в s равен 0
   x[s]=1;			 // Для вершины s найден кратчайший путь
   a=s;				 // Делаем s текущей вершиной
   
   while(1)			 // Перебираем все вершины, смежные a, и ищем для них кратчайший путь
   {
      
      for(b=0;b<p;b++)
      {
         if(a[a][b]==0)continue;			// Вершины b и a несмежные
         if(x[b]==0 && t[b]>t[a]+a[a][b])	//Если для вершины b еще не найден кратчайший путь и новый путь в b короче чем старый, то
         {
            t[b]=t[a]+a[a][b];	//запоминаем более короткую длину пути в массив t
            h[b]=a;	//запоминаем, какая вершина будет предшевствовать следующей
         }
      }

      int w=infinity;  //Ищем из всех длин некратчайших путей самый короткий, инициализируем новую переменную условной бесконечностью.
      a=-1;            // В конце поиска a - вершина, в которую будет найден новый кратчайший путь.
      for(b=0;b<p;b++) // Перебираем все вершины.
      {
         if(x[b]==0 && t[b]<w) // Если для вершины не найден кратчайший путь и если длина пути в вершину b меньше уже найденной, то
         {
            a=b; // текущей вершиной становится b-я вершина
            w=t[b]; // Сначала в бесконечность записываем снова найденную кратчайшую длину, далее заменяем, если таковые были найдены.
         }
      }
   
      if(a==-1)		//Если такого не нашлось, выводим это пользователю.
      {
         cout<<"Нет пути из вершины "<<s<<" в вершину "<<g<<"."<<endl;
         break;
      }
      if(a==g) // Найден кратчайший путь, выводим его
      {        
         cout<<"Кратчайший путь из вершины "<<s<<" в вершину "<<g<<":";
   	   b=g;
   	   while(b!=s)
         {
            cout<<" "<<b;
            b=h[b];
         }
         cout<<" "<<s<<". Длина пути - "<<t[g]<<endl;
   	   break;
      }
   x[a]=1;
}
   return 0;
}